### 1. **Модель AST (ASTNode)**

Абстрактное синтаксическое дерево (AST) служит для представления структуры исходного кода программы в виде иерархической модели. Важно, что каждый узел AST представляет собой конкретную синтаксическую конструкцию, а дочерние узлы — это вложенные элементы этой конструкции.

#### Структура узла:
- **type** — категория синтаксической конструкции, например, "ClassDecl" для объявления класса, "MethodDecl" для объявления метода, "BinaryOp" для бинарной операции.
- **value** — семантическое значение, например, имя класса или метода, операнды бинарной операции.
- **children** — дочерние узлы, представляющие вложенные конструкции, такие как параметры метода или выражения внутри блока.

Такая структура позволяет:
- Рекурсивно представлять код, где каждый узел может иметь свои собственные дочерние элементы.
- Поддерживать визуализацию синтаксического дерева.
- Обеспечить единообразие для всех конструкций языка.
- Легко трансформировать AST для дальнейшего этапа трансляции в промежуточный код или машинный код.

### 2. **Класс SimpleJavaParser**

Парсер реализует рекурсивный нисходящий парсер с поддержкой предпросмотра (lookahead).

#### Поддерживаемые конструкции:
- **Декларации**:
  - Классы с модификаторами доступа, поля и методы, конструкторы.
  - Параметры методов.
- **Управляющие конструкции**:
  - Условные операторы (if-else).
  - Циклы (for, while, do-while, foreach).
  - Операторы перехода (break, continue, return).
  - Блоки кода.
- **Выражения**:
  - Бинарные операции.
  - Вызовы методов.
  - Доступ к членам через `.`.
  - Литералы и идентификаторы.

#### Алгоритм парсинга:
- **Рекурсивный спуск**: Каждая грамматическая конструкция имеет свой метод для парсинга, что помогает естественно отразить иерархию грамматики Java.
- **Предпросмотр (Lookahead)**: Для разрешения неоднозначностей парсер использует функции типа `peek_type(k)`, которые анализируют следующие токены. Это особенно важно для обработки операторов с разным приоритетом.

### 3. **Ключевые методы парсинга**

#### А. **Парсинг выражений**:
Метод парсинга выражений с учетом приоритетов операторов:
```python
def parse_expression(self, min_prec=0):
    # Рекурсивный алгоритм разбора выражений с учетом приоритетов
    # Левая ассоциативность, поддержка бинарных операций
```
Каждый оператор имеет приоритет, который используется для правильной группировки выражений, например:
```python
PRECEDENCE = {
    "MUL": 60, "DIV": 60, "MOD": 60,
    "ADD": 50, "SUB": 50,
    "GT": 40, "LT": 40,
    "EQUAL": 30, "NOTEQUAL": 30,
    "AND": 20, "OR": 10
}
```
Это позволяет правильно интерпретировать выражения с разными уровнями приоритетов.

#### Б. **Парсинг объявлений**:
Методы для парсинга различных объявлений:
- `parse_class_declaration()` — парсинг классов.
- `parse_method_declaration()` — парсинг методов.
- `parse_constructor_declaration()` — парсинг конструкторов.
- `parse_field_declaration()` — парсинг полей.

#### В. **Парсинг операторов**:
Методы для парсинга различных операторов:
- `parse_if_statement()`, `parse_for_statement()`, `parse_while_statement()`, и т. д.

### 4. **Обработка особых случаев**

Особое внимание уделяется распознаванию специфических конструкций языка, таких как:

- **Циклы for**: Различие между обычным циклом `for (init; cond; update)` и циклом `for (Type var : collection)` требует просмотра следующего токена (`COLON`) для правильной интерпретации.
  
- **Обработка массивов**: Включение поддержки массивов, например, типа `String[] args`, где важно корректно интерпретировать объявление типа с массивом.

- **Локальные переменные и выражения**: Парсер должен умело различать объявления локальных переменных и выражения присваивания. Это важно для правильной обработки различных типов конструкций, например:
  ```java
  int x = 10;  // Объявление переменной
  x = 20;      // Присваивание
  ```

### 5. **Процесс синтаксического анализа**

Процесс синтаксического анализа представляется следующим образом:

1. **Поток токенов от лексера**: Лексер преобразует исходный код в поток токенов.
2. **Инициализация парсера**: Запуск класса `SimpleJavaParser` с обработкой потока токенов.
3. **Метод `parse_compilation_unit()`** — корневой метод парсинга, который инициализирует разбор всего исходного кода.
4. **Распознавание объявлений верхнего уровня**: На этом этапе парсер распознает объявления классов, методов и других элементов.
5. **Рекурсивный парсинг тел методов и блоков**: В процессе парсинга тело метода или блока кода разбирается с рекурсией.
6. **Построение AST**: В ходе парсинга строится абстрактное синтаксическое дерево, которое используется для дальнейшей трансляции или анализа.
