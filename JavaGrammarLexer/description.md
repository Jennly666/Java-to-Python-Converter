### 1. **Базовый класс Lexer**

**Назначение**:  
Класс `Lexer` предоставляет общую инфраструктуру для обработки текста исходного кода и выделения из него лексем (токенов).

#### Ключевые особенности:

- **Управление состоянием**: Лексер отслеживает текущую позицию в исходном коде с помощью переменных:
  - `_line`: текущая строка.
  - `_column`: текущая позиция в строке.
  - `_index`: глобальная позиция в тексте (индекс символа).
  
  Эти данные позволяют лексеру отслеживать и правильно обновлять информацию о местоположении в тексте, что важно для диагностики ошибок.

- **Создание токенов**:  
  Лексер использует метод `emit()` для создания токенов. Этот метод обращается к токен-фабрике (например, `CommonTokenFactory`), которая создает объект токена с нужным типом и значением.

- **Обработка EOF (конец файла)**:  
  Метод `emitEOF()` генерирует специальный токен, сигнализирующий о завершении потока токенов, что необходимо для корректной обработки конца исходного кода.

- **Сбор результатов**:  
  Метод `getAllTokens()` собирает и возвращает полный список токенов, извлеченных из исходного кода.

#### Важные особенности:
- Использует **CommonTokenFactory** для создания токенов, что упрощает работу с различными типами токенов.
- Поддерживает систему каналов (например, **DEFAULT_CHANNEL** и **HIDDEN**), что помогает разделить основной код и такие элементы, как пробелы и комментарии.
- Обеспечивает наличие абстрактного метода `nextToken()`, который должен быть реализован в дочерних классах лексеров для извлечения следующего токена.

---

### 2. **Конкретная реализация JavaGrammarLexer**

**Назначение**:  
`JavaGrammarLexer` является конкретной реализацией лексера для языка Java. Этот лексер анализирует исходный код Java и выделяет лексемы, соответствующие синтаксису Java.

#### А. **Полнота охвата языка Java**

- **Ключевые слова (KEYWORDS)**:  
  Лексер поддерживает 52 ключевых слова Java, такие как `class`, `public`, `static`, `void`, и т.д. Они преобразуются в константные идентификаторы (например, `"class"` → `CLASS`).

- **Операторы и символы (SYMBOLS_MAP)**:  
  Лексер распознает как простые односимвольные операторы (например, `+`, `-`, `*`, `=`), так и более сложные многосимвольные операторы:
  - **Многосимвольные операторы**: `>>=`, `->`, `::`, `...`.
  - **Составные операторы присваивания**: `+=`, `-=`, `>>=`.
  
  С помощью карты символов лексер эффективно преобразует операторы и разделители в соответствующие токены.

#### Б. **Эффективная реализация на регулярных выражениях**

- Лексер использует предкомпилированные регулярные выражения для распознавания различных лексем. Каждое регулярное выражение отвечает за конкретный тип лексем:
  
  - **_whitespace_re**: Распознает пробельные символы (пропускаются).
  - **_comment_re**: Обрабатывает однострочные и многострочные комментарии, которые помещаются в **HIDDEN_CHANNEL**, чтобы их игнорировал парсер.
  - **_string_re** и **_char_re**: Строки и символы с учетом экранирования.
  - **_number_re**: Числовые литералы (целые числа, вещественные, экспоненциальные).
  - **_identifier_re**: Идентификаторы и ключевые слова.
  - **_symbol_re**: Операторы (сортируются по длине для приоритетного распознавания более длинных конструкций).

- **Оптимизированный порядок распознавания**:
  1. Пробелы → Пропуск.
  2. Комментарии → HIDDEN.
  3. Строки и символы → STRING/CHAR.
  4. Числа → NUMBER.
  5. Идентификаторы → IDENTIFIER или KEYWORD.
  6. Символы → Простой оператор из SYMBOLS_MAP.
  7. Неизвестное → UNKNOWN.

  Это порядок обеспечивает правильную работу лексера, минимизируя вероятность ошибок при распознавании различных лексем.

#### В. **Управление позиционной информацией**

- Метод **_advance_position()** обновляет позиционную информацию:
  - **Абсолютную позицию** (_pos, _index), которая соответствует текущему положению в тексте.
  - **Относительную позицию** (_line, _column), которая отслеживает строку и столбец с учетом переводов строк.

#### Г. **Обработка особых случаев**

- **Комментарии**: 
  Они игнорируются парсером, так как их помещают в канал **HIDDEN**, но они сохраняются в списке токенов для возможной последующей обработки.
  
- **Ключевые слова vs идентификаторы**: 
  Лексер сначала распознает токен как идентификатор и только затем проверяет, является ли он ключевым словом. Это предотвращает ошибочную идентификацию ключевых слов как идентификаторов.

- **Многосимвольные операторы**:
  Лексер сортирует операторы по длине (от самых длинных к более коротким), чтобы гарантировать правильное распознавание, например, `>>=` перед `>`.

- **Неизвестные символы**:
  Символы, которые не соответствуют ни одному из шаблонов, возвращаются как токены типа `UNKNOWN`, предотвращая зацикливание лексера.

---

### 3. **Процесс лексического анализа**

1. **Исходный код** (текст программы) поступает в лексер через **FileStream**.
2. Лексер вызывает **JavaGrammarLexer.nextToken()** для извлечения токенов.
3. Лексер последовательно пропускает:
   - Пробельные символы (пропускаются).
   - Комментарии (помещаются в канал HIDDEN).
   - Строковые и символьные литералы, числа, идентификаторы, операторы и символы.
4. В результате получается **TokenStream** — поток токенов, который используется для дальнейшего анализа и обработки исходного кода.
