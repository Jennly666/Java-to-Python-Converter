## 1. **Описание транслятора (Translator)**

### **Архитектурная роль**

Транслятор преобразует **абстрактное синтаксическое дерево (AST)** Java в эквивалентный **исполняемый код на Python**.

---

## 2. **Детальное описание модуля транслятора**

### 2.1. **Архитектура преобразования типов**

**Система маппинга типов (`TYPE_MAP`, `map_java_type_to_py`):**

| Java тип   | Python эквивалент | Особенности                            |
| ---------- | ----------------- | -------------------------------------- |
| `int`      | `int`             | —                                      |
| `boolean`  | `bool`            | —                                      |
| `String`   | `str`             | —                                      |
| `void`     | `None`            | отсутствие возвращаемого значения      |
| `char`     | `str`             | Python не имеет отдельного типа `char` |
| `String[]` | `list[str]`       | рекурсивное преобразование массивов    |
| `int[][]`  | `list[list[int]]` | поддержка многомерных массивов         |

**Пользовательские типы:** сохраняются с преобразованием имени в стиль Python.

**Значения по умолчанию (`DEFAULT_FOR_TYPE`):**

* `int → 0`
* `bool → False`
* `list → []`

Это предотвращает ошибки времени выполнения и обеспечивает корректную инициализацию переменных в Python.

---

### 2.2. **Стратегия трансляции выражений**

**Метод:** `_expr_to_source()` — универсальный конвертер выражений.

**Маппинг операторов:**

```python
op_map = {
    "GT": ">", "LT": "<", "GE": ">=", "LE": "<=", 
    "EQUAL": "==", "NOTEQUAL": "!=", "AND": "and", "OR": "or"
}
```

**Специальные преобразования:**

* `System.out.println()` → `print()`
* `System.out.print()` → `print(..., end='')`
* Инкременты/декременты: `i++` → `i += 1`
* Присваивания в конструкторах: `field = value` → `self.field = value`

**Контекстно-зависимые преобразования:**

* Учитывается область видимости и принадлежность к экземпляру класса.

---

### 2.3. **Трансляция структурных конструкций**

#### **А. Классы и методы**

**Классы:**

* Сохранение иерархии и корректных отступов.
* Автоматическая генерация `pass` для пустых тел.

**Методы:**

* Преобразование сигнатур с типами параметров.
* Добавление `self` для нестатических методов.
* Использование `@staticmethod` для статических методов.
* Аннотация возвращаемых типов.

**Конструкторы:**

* `ClassName(...)` → `__init__(self, ...)`
* Специальная обработка присваиваний полей внутри конструктора.

---

#### **Б. Управляющие конструкции**

**Условные операторы:**

* Полная поддержка `if-elif-else` цепочек.
* Сохранение вложенности и областей видимости.

**Циклы:**

* Интеллектуальное преобразование `for`:

  * Распознавание шаблонов `for (int i = 0; i < N; i++)` → `for i in range(0, N):`
* `while` циклы: прямое преобразование с сохранением логики.
* `do-while`: эмуляция через `while True` и `break` при несоблюдении условия.

**Switch → Match:**

* Используется конструкция `match-case` (Python 3.10+).
* Поддержка `default` через `case _:`.

---

### 2.4. **Обработка особых случаев и эвристики**

**Распознавание шаблонов циклов `for`:**

```java
// Java
for (int i = 0; i < 10; i++)
```

```python
# Python
for i in range(0, 10):
```

**Эвристики включают:**

* Анализ инициализатора, условия и шага цикла.
* Распознавание инкрементов/декрементов (`++`, `--`).
* Определение направления и шага цикла.

**Обработка коллекций:**

* `foreach`-циклы:

  ```java
  for (Type item : collection)
  ```

  →

  ```python
  for item in collection:
  ```

---

### 2.5. **Система отступов и форматирования**

* Гибкое управление отступами.
* Конфигурируемый строковый индентатор.
* Рекурсивное увеличение/уменьшение уровня вложенности.
* Поддержание читаемости сгенерированного кода.

---

## 3. **Полный процесс трансляции**

```
Java исходный код
     ↓
FileStream (символы)
     ↓
JavaGrammarLexer (токены)
     ↓
SimpleJavaParser (AST)
     ↓
Translator (Python код)
     ↓
Исполняемый Python код
```

---

## 4. **Пример комплексного преобразования**

**Исходный Java код:**

```java
public class Calculator {
    private int value;
    
    public Calculator(int start) {
        this.value = start;
    }
    
    public int add(int x) {
        for (int i = 0; i < x; i++) {
            value++;
        }
        return value;
    }
}
```

**Результирующий Python код:**

```python
class Calculator:
    value: int = 0
    
    def __init__(self, start: int):
        self.value = start
    
    def add(self, x: int) -> int:
        for i in range(0, x):
            self.value += 1
        return self.value
```
