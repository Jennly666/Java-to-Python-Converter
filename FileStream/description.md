### 1. **FileStream - Файловая реализация входного потока**

**Назначение:** Это конкретная реализация `InputStream`, которая работает с файлами. В отличие от абстрактного потока, этот класс ориентирован на чтение данных из файловой системы.

- **Чтение файлов:**  
  Загружает содержимое файлов, например, исходных кодов, из указанной директории. Это важно для программ, которые работают с большими наборами данных, лежащими в файлах.
  
- **Поддержка кодировок:**  
  Использует метод `codecs.decode()` для корректной обработки различных кодировок файлов (например, UTF-8, UTF-16 и другие). Это обеспечивает корректную работу с текстами, содержащими символы, которые могут быть закодированы по-разному.
  
- **Бинарное чтение:**  
  Читает файлы в бинарном режиме, что позволяет избежать проблем с преобразованием символов конца строки (например, между Windows и Linux). Это также важно для обработки двоичных данных в файле.

---

### 2. **InputStream - Базовый класс входного потока**

**Назначение:** Это абстракция для потока символов, который позволяет читать исходный код. В программировании часто приходится работать с потоком данных, и этот класс предоставляет базовые функции для этого.

- **Посимвольное чтение:**  
  Методы `LA()` и `LT()` позволяют "заглядывать" вперед в потоке, чтобы предсказать, что будет дальше, не изменяя текущую позицию. Это удобно для парсеров, которые анализируют код построчно.
  
- **Управление позицией:**  
  `consume()` сдвигает текущую позицию потока, что важно для чтения и обработки каждого символа поочередно. А метод `seek()` позволяет перемещаться в поток на конкретную позицию, что важно при реализации операций с откатом (backtracking).
  
- **Извлечение текста:**  
  `getText()` позволяет извлечь подстроку исходного текста между заданными индексами. Это полезно для получения информации о том, какой именно текст был обработан.

- **Отслеживание состояния:**  
  Позиция в потоке отслеживается через свойства `index` (текущая позиция) и `size` (общий размер данных). Это помогает понимать, сколько данных было прочитано и на какой стадии находится обработка.

**Особенности:**
- Работа с **Unicode-символами** через их числовые коды с использованием функции `ord()`.
- Возвращает **Token.EOF**, когда достигается конец потока — сигнализирует о том, что нет больше данных для чтения.
- Поддерживает **backtracking** через маркеры (`mark()` и `release()`), что полезно для парсеров, которым нужно вернуться к предыдущим данным.

---

### 3. **Token и CommonToken - Модель токенов**

**Назначение:** Эти классы представляют лексические единицы, или токены, которые извлекаются лексером при анализе исходного кода. Токен — это элемент языка программирования (например, ключевое слово, идентификатор, число и т.д.).

- **Token:**  
  Абстрактный базовый класс для всех токенов, определяющий интерфейс и обязательные атрибуты, такие как `type` (тип токена), `text` (содержание), `start` и `stop` (индексы начала и конца в исходном потоке), `line` и `column` (позиция в исходном коде).

- **CommonToken:**  
  Конкретная реализация класса `Token` с полной функциональностью. Этот класс будет использоваться для создания реальных токенов.

**Важные атрибуты токена:**
- `type`: Тип токена (например, ключевое слово, оператор, идентификатор).
- `text`: Текстовое представление токена.
- `start` и `stop`: Указывают индексы начала и конца токена в исходном потоке.
- `line` и `column`: Позиция токена в исходном коде, полезно для диагностики ошибок.
- `channel`: Определяет, является ли токен видимым для анализа (например, скрытые токены для комментариев или пробелов).

**Константы:**
- `EOF`: Специальный маркер конца файла.
- `DEFAULT_CHANNEL` и `HIDDEN_CHANNEL`: Разделение токенов на видимые (основные) и скрытые (например, комментарии или пробелы).

---

### 4. **CommonTokenFactory - Фабрика токенов**

**Назначение:** Это фабрика для создания токенов. Она инкапсулирует логику их создания и обеспечивает согласованность в процессе генерации токенов.

- **Инкапсуляция логики создания:**  
  Упрощает создание токенов и гарантирует, что все токены будут создаваться одинаково. Это важный момент для поддержания порядка в обработке данных, особенно в больших проектах.

- **Согласованность:**  
  Поскольку фабрика всегда создаёт токены одинаково, это упрощает тестирование и отладку парсеров.

- **Расширяемость:**  
  Легко добавить дополнительные функции или настроить фабрику под специфические нужды проекта, если нужно, например, добавлять новые типы токенов.


### **Место в общей архитектуре**

<img width="498" height="166" alt="image" src="https://github.com/user-attachments/assets/69f05a0a-5af9-4eef-b07e-a26867858d2c" />
